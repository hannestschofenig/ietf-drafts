.af % 1
.nr % 1
.af PN 1
.if n .pl 10.0i
.po 0
.if n .ll 7.2i
.if n .lt 7.2i
.if n .nr LL 7.2i
.if n .nr LT 7.2i
.ds LF Rescorla, IAB
.if n .ds RF FORMFEED[Page %]
.if t .ds RF [Page %]
.ds CF
.ds LH Internet-Draft
.ds RH 04/08
.ds CH Authentication Mechanisms
.hy 0
.ad l
.in 0
.	\" my display keep defs
.de xS
.DS
.if t .S
..
.de xE
.DE
.if t .R
..
.	\" my para defs
.de sP
.PP
.in 3
..
.de eP
.in 0
..

\" New section
.de nS 
.NH \fR\\$1
\\$2
.if !'\\$3'' .tm EKRXREF \\$3 \\*(SN
.tm SECTION \\*(SN \\n[PN] \\$2
..      \" new section

.rm nL
\" Numbered list entry
.de nL
.ie \\$1 .nr list*number \\$1
.el .nr list*number \\n[list*number]+1
.sP
.in 6
\\n[list*number].
..

\" FL is the previous figure
\" FN is The next figure 
.de nF
.sp -1
.if !\\n(NF .nr NF 1
.nr NF \\n(NF+1	
.ds FL \\*(FN
\" .ds FN \\*(CN.
.ds FN \\n(NF
.ps -1
.ce 1
Figure \\*(FL: \\$1
.if !'\\$2'' .tm EKRXREF \\$2 \\*(FL
.ps 
.sp 
..

.nf
                                                             E. Rescorla
                                                 Network Resonance, Inc.    
                                             Internet Architecture Board
INTERNET-DRAFT                                                       IAB
<draft-iab-auth-mech-06.txt>           April 2008 (Expires October 2008)

.fi
.ce
A Survey of Authentication Mechanisms
.LP
Status of this Memo
.sP
.nf
   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

Copyright Notice
   
   Copyright (C) The Internet Society (2006).
.fi
.eP
.sH
Abstract
.sP
Authentication is a common security issue for the design of
Internet protocols. A wide variety of authentication technologies
are available. A common problem is knowing which technology to
choose or which of a variety of essentially similar implementations
of a given technique to choose. This memo provides a survey
of available mechanisms and guidance on selecting one for a
given protocol.
.eP
.sH
Contents
.sP
.so toc.txt
.nS 1 "Introduction"
.sP
Authentication is perhaps the most basic security problem for 
designers of network protocols. Even the early Internet protocols
such as TELNET and FTP, which provided no other security
services, made provision for user authentication. Unfortunately,
these early authentication systems were wholly inadequate 
for the Internet Threat Model [SECCONS] and a vast array of other 
authentication mechanisms have been introduced in an attempt
to close these holes.
.sP
The most striking thing about these security mechanisms is how
many of them are essentially similar. There are only 7 basic
classes of authentication protocol but there are 
a large number of slightly different protocols with essentially
the same security properties. This memo surveys the space
of authentication mechanisms, describes the basic classes and
provides examples of protocols which fit into each class.
.eP
.nS 1 "The Authentication Problem"
.sP
The authentication problem is simple to describe but hard to solve:
Two parties are communicating and one wishes to establish its
identity to another. 
The basic scenario is exemplified by TELNET. A client
(on behalf of a user) wishes to remotely access resources
on a TELNET server. The user has an account on the server
and the server remembers the user's authentication information
but the client itself may have no long-term storage and only
limited computational capabilities. The client side of
the credentials must be able to be carried by the user,
either on a small device or in his memory. Note that 
the major technical division here is between situations in
which there is any clients-side storage (for instance for
cryptographic keys) and ones where any authentication material
must be memorized.
.eP
.nS 2 "Authorization vs. Authentication"
.sP
AUTHORIZATION is the process by which one determines whether 
an authenticated party has permission to access a particular 
resource or service. Although tightly bound, it is important to realize 
that authentication and authorization are two separate mechanisms. 
Perhaps because of this tight coupling, authentication 
is sometimes mistakenly thought to imply authorization. 
Authentication simply validates the identity of a party; authorization
defines whether they can perform a certain action.
.sP
Authorization necessarily relies on authentication, 
but authentication alone does not imply authorization.  
Rather, before granting permission to perform an action,
the authorization mechanism must be consulted to determine whether  
that action is permitted. This document is solely concerned
with authentication.
.eP
.nS 2 "Something you have, something you know, something you are"
.sP
The classic formulation of authentication is that there are
three kinds of mechanisms:
.nf
1. Something you have--a physical token like a key.
2. Something you know--a secret, e.g., a password
3. Something you are--some physical characteristic particular to you.
.fi
.sP
The best authentication mechanisms combine two or more of these
mechanisms. For instance, if you use a driver's license or a
passport to authenticate, that's something you have (the license)
and something you are (your resemblance to the picture on
the license).
In practice, biometric authentication mechanisms work poorly
over the Internet, so the best Internet authentication mechanisms
will involve a token plus a secret.
.eP
.nS 2 "Clients and Servers"
.sP
Most of the protocols which run on the Internet are inherently
asymmetric, with one peer taking the role of the client and the
other the server. Because the servers are generally fixed 
machines with a fixed address and the clients may have any
address, many protocols (such as SSH or TLS) 
operate by attempting to authenticate the server and then 
authenticate the client. When such systems are used in peer-to-peer
contexts, it is still necessary for one peer to take on the client 
role and one the server. Typically, the party which spoke first
(the initiator) is treated as the client. 
.sP
Even protocols which are
peer to peer (such as IKE) require one party to speak first.
In such cases, it's appropriate to refer to that party as
the initiator and the other as the responder.
.eP
.nS 1 "Description of Authentication Mechanisms"
.sP
The next seven sections each describe a single class of authentication
technology. In each case, we first describe the technology in general,
with possible subsections describing security or implementation issues
that are generic to this technology. Once we have described the
technology in general we then provide one or more case studies:
descriptions of specific protocols which use this authentication
technology and the various security or implementation issues that are
specific to that protocol. Thus, each section uses the
following pattern.
.eP
.xS
A Mechanism
  (Description)
A.x risk
  (description and countermeasures)
A.y risk
  (description and countermeasures)
A.z Case Study: Specific Protocol
  (description of the protocol)
A.z.x Protocol Specific problems.
A.w List of known Protocols/Systems that use this mechanism
.xE
.nS 1 "Passwords In The Clear"
.sP
The most commonly used form of authentication is for the client
to provide a username/password pair to the server in the
clear (e.g. over a TCP channel). The server then verifies
the password against the user's stored credentials. If they
match, the server allows the client to access the resource.
.sP
The most primitive approach is for the server to simply store
the user's username and password in a file on the server's
disk. This has the serious problem that if the password
file is somehow compromised, the attacker has immediate
access to all user passwords and can log in as any user.
The standard approach, first described by Wilkes [WILKES]
is to store the output of a one-way function (typically a cryptographic
message digest (see [GLOSSARY] for a definition of terms
like this))
the password instead of the password itself.
When the server needs to verify a password, it 
computes the function using the password as input
the password and compares the output against the stored
output. Because the function is one way, the server cannot
recover the user's password from the password file.
.eP
.nS 2 "Password Sniffing"
.sP
The simplest attack against passwords in the clear is simple
password sniffing. The attacker arranges to intercept
traffic between the client and the server (this is relatively
easy, especially if the attacker is on the same network as
one of the endpoints). Since the password traverses the network in
the clear, the attacker is easily able to recover the password
and can use it for any future authentications.
.eP
.nS 2 "Post-Authentication Hijacking"
.sP
An attacker who can hijack network connections need not know
the user's password at all. He can simply wait for the 
user to complete his authentication and then take over the
connection. This attack is more difficult to mount than
password sniffing, but as we'll see later, it can be
useful when stronger authentication schemes are employed.
.eP
.nS 2 "Online Password Guessing"
.sP
Extensive experience [KLEIN] shows that users choose bad passwords.
Common choices include the user's real name, login name, 
date of birth, and simple dictionary words. An attacker with
no special capabilities can therefore attack a server by simply
trying known or common usernames and common passwords. This 
technique was used to great effect by the Morris worm [WORM].
.sP
The standard countermeasure to this attack is to make it
difficult for the attacker to try a large number of passwords.
This can be done by incorporating a LIMITED TRY capability. After
some number of failed attempts, the system simply locks the 
account and the user cannot log in even with the correct password.
Unfortunately, simple limited try provides the attacker with
an easy denial-of-service (DoS) attack--he can lock any account simply
by performing failed logins.
.sP
A superior approach is to incorporate
a delay. For instance, the system might allow the 
user to immediately try 3 passwords, but after three failures
lock the account for 10 seconds, increasing the 
delay (up to some fixed maximum) for each failure. This is a less
effective countermeasure than simple LIMITED TRY
but resists the DoS attack better.
.eP
.nS 2 "Offline Dictionary Attack"
.sP
Even if digested password files are used, it still often
possible for an attacker who recovers the password file to
discover user's passwords. The attacker can mount an OFFLINE DICTIONARY
ATTACK on the password file. A dictionary attack uses
the fact that users tend to choose words rather than random
strings in order to narrow the scope of exhaustive search.
The attacker simply runs through each word (and common variations)
in sequence, comparing the digest of the trial word against the
digest in the password file. There are a number of programs available
to mount this sort of attack, including the classic Crack [CRACK] program.
.eP
.nS 3 "Shadow Passwords"
.sP
There are four basic countermeasures to offline dictionary attack.
The first is to deny attackers the password digest. In the original
UNIX systems, reading the password file was the only way to get
information about users and therefore the password file had to be
publicly readable. Later systems introduced SHADOW PASSWORDS,
whereby the password file contained a dummy password and a second
copy of the password file containing the encrypted passwords was
unreadable except to root. Thus, unprivileged user processes would
consult the ordinary password file (now containing dummy passwords) to
get user information (such as name, home directory, etc) but
only privileged processes can read the encrypted passwords.
Of course, sometimes an attacker
can convince a privileged process (via bugs) to give him a copy of the
file, thus allowing him to attack it.
.eP
.nS 3 "Iteration"
.sP
The second type of countermeasure is to make search slower. One approach
is to simply make the hash function slower. The original UNIX crypt()
function did this by repeating the basic operation (based on DES) 25
times. (The designers also slightly modified the operation so that it couldn't
be done with ordinary DES hardware.) The idea here is that noone will
notice a second or so delay on login but that making each guess take
a second will seriously slow down an attacker. To compensate for the speed of
modern computers, rather more iterations are currently required each
year.
.eP
.nS 3 "Salting"
.sP
If a simple hash of the password is stored in the password file, then
an attacker can attack all the passwords in the file in parallel. He simply
generates the hash of each candidate and then compares it against
each stored hash. In order to prevent this attack, many systems 
SALT the hash with some random value (which is different for
each user). Thus, instead of storing
simply H(password) they store salt || H(salt || password), with
the result that even two users who have the same password will
in general not have the same stored password hash. One interesting
innovation is to use a secret salt. This requires the attacker
to try all possible salts, automatically slowing down the process 
(thereby making iteration unnecessary).
.eP
.nS 3 "Stronger Passwords"
.sP
The reason that dictionary attacks are so easy is that users choose
bad passwords. Even the 8 character UNIX password space allows
2^56 possible passwords\*-a search space that is impractical for
most attackers to search. One obvious countermeasure is to
force users to choose good passwords. This can be done reactively
by running a password cracker on your system or proactively by
forcing users to use good passwords when they set them. It's also
possible to force users to use randomly generated passwords. Unfortunately,
unguessable passwords are often less memorable, causing users to
write them down. It's not clear that this is an improvement. 
Security-conscious people are often willing to use complex mnemonics to
help remember random passwords but ordinary users are not.
One welcome innovation on this front is the replacement
of the old UNIX DES-based crypt() function with an MD5-based function that
accepts longer passwords, allowing the user to have a meaningful but still
harder to guess password.
.eP
.nS 2 "Case Study: HTTP Basic Authentication"
.sP
HTTP basic authentication  [RFC2617] is the original HTTP authentication
mechanism. It's a simple username/password scheme. The server
prompts the client with a request for authentication (in a 
WWW-Authenticate header). The client responds with the 
password in an Authorization header. The password is 
base-64 encoded but this doesn't provide any security,
just protection from damage in transport.
.eP
.sH
.nS 3 "Password Caching"
.sP
Any reasonable Web page fetch consists of a number of HTTP
fetches, each of which may requires HTTP authentication.
Requiring the user to type in his password for each such
fetch would be prohibitively intrusive. Accordingly, web clients
typically cache the user's password for some time (generally for
the lifetime of the browser process.)
.sP
In some cases, the browser will cache password on disk so
that the user never has to type in the password again.
This practice introduces a new security problem: protection
of the user's cached passwords. These passwords can be
encrypted on disk (under another password) but users often
find this inconvenient and so the passwords are often
stored on the disk in the clear. This is dangerous
on multi-user machines, even ones which provide
strong file permissions, since administrators can still
read such cache files.
.eP
.nS 3 "Pro-active authentication"
.sP
Requesting a page, receiving an authentication challenge and re-requesting
with a password introduces an extra round-trip. This latency
can be quite significant if the original request was large,
such as with a file PUT. Thus, many clients
pro-actively send their cached passwords whenever accessing any
URL deeper than the URL for which they were originally prompted.
.eP
.nS 2 "List of Systems that Use Passwords in the Clear"
.sP
.nf
TELNET
HTTP (basic authentication)
SASL (password mode)
RLOGIN
POP (among others mechanisms)
IMAP (among other mechanisms)
(too many others to mention)
.fi
.eP
.nS 1 "One Time Passwords"
.sP
The simplest approach to preventing sniffing attacks on passwords is
to use ONE TIME PASSWORDS. In its basic form, the user
is provided with a list of passwords, each of which can
only be used once, making replay attack impossible. The
passwords are still transmitted in the clear, but since
each one can only be used once, a sniffed password cannot
be used as an authenticator.
.sP
The major use of one-time password systems is to improve
the security of protocols which previously used password
authentication. One-time password schemes can be designed
such that they require no changes to the client software
and only minimal changes to the server software. The
user generally needs to have either a physical password
list or a token that computes the password, but the client
software
does not need to be replaced and the wire protocol is
unchanged.
.sP
None of the one-time password schemes are very useful for
automated authentication, since they only provide a limited
number of keys. Using automated authentication with
S/Key or OTP it is easy to quickly use up a large number
of keys. SecurID provides an essentially infinite number 
of keys but they are changed too infrequently to be usable
in most automated systems. 
.sP
As with ordinary passwords, one time password mechanisms
are subject to a number of active attacks. However, even
if the attacker captures a specific authenticator via an
active attack, he can use it only once, not indefinitely.
.eP
.nS 2 "Case Study: S/Key and OTP"
.sP
S/Key [SKEY], invented by Neil Haller and Phil Karn, is a straightforward
one time password system that uses some clever implementation
tricks. One-Time Passwords (OTP) [OTP] is the successor protocol 
to S/Key,
standardized by the IETF. In S/Key, the one time passwords are constructed by
iteratively hashing a public seed and a secret. Thus:
.xS
P[0] = H(Seed,Secret)
P[i] = H(P[i-1]).
.xE
.sP
Passwords are used in reverse order. This allows the server
to simply store the last password that it received (P[i]).
The client will next authenticate with P[i-1]. The server
can verify a password by hashing it and checking to
see if it matches the stored password. Once authentication
is complete, the server simply deletes the old password and
stores the new one. 
.sP
S/Key uses a special password encoding that's designed to
make it easy for users to type passwords without errors. The
64-bit one-time password is broken up into a sequence of 
six 11-bit values (with the remaining two bits being used as
a checksum). Each 11-bit value is used as an index into
a fixed dictionary of 2048 short words. Thus, a password
might look like:
.xS
INCH SEA ANNE LONG AHEM TOUR
.xE
.sP
This encoding is intended to be easier to type than
base64 or hexadecimal. (Though hexadecimal is defined as
well).
.sP
S/Key can be used in two modes. In the first, the client
is simply provided with a list of passwords on a piece of
paper. He uses one at a time and crosses them off as he
goes. In this case, the Secret is usually cryptographically
random.
In the second mode, the client has a token or a computer
program that he uses to calculate the appropriate S/Key key.
In this case, the Secret is generally some user-memorable
password which the user keys into the program or token.
.sP
S/Key scheme has a number of nice properties. First, the password
file need not be kept secret, since going from P[i] to P[i-1] requires
reversing the message digest, which is believed to be computationally
infeasible. (Note: if a text password is used as the secret
then the password file is still subject to dictionary attack,
but a passive attacker who recovers ANY S/Key authenticator can mount
a dictionary attack on it (by iteratively hashing the 
potential seed), so it's not that important to
keep the password file per se secret).
.sP
Second, it's easy for the user to rekey: He simply creates a new
Secret, generates a set of keys and sends the last one to the
server. Note that it's of course possible for an active
attacker to hijack a connection and rekey with a key of
his choice, thus one time passwords are in general a poor choice
when active attack is part of the threat model.
.eP
.nS 3 "Race Conditions"
.sP
S/Key has an interesting security flaw:
Consider a protocol where passwords are transmitted one character
at a time. A passive attacker might wait for the victim to
log in and then create his own login connection at the same
time. The attacker would then echo the victim's password character
for character, until there was only one character left. At this
point the attacker would simply guess the last character
and then complete the authentication. This attack is relatively
simple to mount because nearly all the words in the S/Key dictionary
are 4-characters long and the number of words with any given
3-letter prefix is generally quite small (2 or 3).
.sP
The standard countermeasure to this attack is to only allow
one pending authentication for a given user at any given time.
In order to prevent DoS attacks, there must be at timeout
on any such pending connection. OTP implementations are 
required to implement this or some other countermeasure.
.eP
.nS 2 "Case Study: SecurID"
.sP
Probably the most commonly deployed commercial one time password
implementation is SecurID, sold by RSA Security Inc.
Instead of using a fixed list of keys,
SecurID uses a time-dependent key. The user has a token with
an LCD displaying a pseudo-random number. That number changes
at an interval between 30 seconds and 2 minues
and is synchronized with an authentication server
located at the server.
.sP
In order to authenticate the user
enters both his PIN and the time-dependent key (they 
can be concatenated so that this is transparent to the client program.)
The server verifies the password and checks that the time-dependent
key is correct for the current time and only then allows
login. It's clearly possible for an attacker to capture the
password and replay it but without the token he (theoretically)
can't generate the right time-dependent key. 
.eP
.nS 2 "List of One-Time Password Systems"
.sP
Note: any system that uses passwords can be adapted to use
one-time passwords.
.sp
.nf
S/Key [SKEY]
OTP [OTP]
SecurID [RFC 2808]
.fi
.eP
.nS 1 "Challenge/Response"
.sP
CHALLENGE/RESPONSE mechanisms fix the sniffing problem associated
with ordinary passwords. The basic idea is simple: the verifying party
provides a random (or at least unique) challenge and the authenticating
party returns some function of the shared key and the challenge. Generally
this function is some sort of message digest. In the simplest form it is
H(challenge || key), where H is a cryptographic message digest 
(see RFC 3552 for an and
"||" denotes message concatenation.
A better design is probably to use HMAC [HMAC], which
has stronger security guarantees. 
.sP
Challenge/response mechanisms are resistant to simple sniffing attacks
but in general have all the other security problems of ordinary
password systems. Additionally, they are vulnerable to 
another form of offline dictionary attack and are more vulnerable to
password file compromise than correctly implemented password in
the clear systems.
.sP
Challenge/response mechanisms can be completely hardened against
offline dictionary attacks by the use of a sufficiently large
randomly-generated shared key instead of a password. Such a password
is of course difficult for a user to memorize but is quite useful
if it can be statically configured on both sides of a connection.
.sP
Unlike simple password mechanisms, challenge/response mechanisms
can be designed which provide both mutual authentication and secure
key exchange. Such systems can be made resistant to most forms of active
attack, and depending on the strength of the shared key, passive
attacks as well.
.eP
.nS 2 "Offline Attacks on Challenge/Response"
.sP
Although a passive attacker cannot mount an ordinary sniffing
attack, he can combine sniffing with an offline dictionary attack.
The attacker simply captures a single challenge/response exchange
and then dictionary searches the password space until he finds
a password that produces the correct response for a given challenge.
With high probability (though not certainty) this will be the
correct password. This problem is inherent in all simple challenge
response mechanisms and cannot be fixed without public-key technology.
This problem is inherent unless public-key methods are
incorporated within the challenge-response protocol, as will be discussed in
Section 7 and 8, or the challenge-response transactions are carried over
secure channels (which themselves must be authenticated).
.eP
.nS 2 "Password File Compromise"
.sP
Challenge/response mechanisms also introduce a new problem: 
PASSWORD EQUIVALENCE. In order to locally compute (for verification
purposes) the appropriate response for a given challenge, the 
server must store the user's password locally. Thus, if the
password file is compromised, the attacker can directly log
in to the server, without even needing to crack the password
file. We'll call this property WEAK PASSWORD EQUIVALENCE.
.sP
A more serious variant of the same problem occurs if users
use the same password on multiple systems. Compromise of
one system can thus lead to compromise of many. This is
called STRONG PASSWORD EQUIVALENCE. This
risk should not be overstated\*-compromise of an ordinary
password system can still lead to attack if the attacker
completely compromises the system and can capture people's passwords
when they login\*-but is nevertheless worse in challenge/response
than with ordinary passwords. The standard countermeasure is
to use a two-stage digesting process, such as:
.eP
.xS
STORED	 = H(PASSWORD || SALT)
RESPONSE = H(STORED || CHALLENGE)
.xE
.sP
The server stores STORED instead of the password. (Making
STORED effectively the password). The server
then gives the client both SALT and CHALLENGE, allowing the
client to compute RESPONSE from the password alone. Note
that the two-stage process only prevents compromise of one
system from affecting others. Compromise of a password
file still allows immediate access to the target system.
.eP
.nS 2 "Case Study: CRAM-MD5"
.sP
CRAM-MD5 [CRAMMD5] is a challenge/response authentication extension
for IMAP [IMAP]. CRAM-MD5 is a classic challenge/response system:
the server provides a presumably random challenge and the client
transmits an HMAC of the challenge using the shared key
as the HMAC key. The interaction looks like this:
.eP
.xS
1 S: * OK IMAP4 Server
2 C: A0001 AUTHENTICATE CRAM-MD5
3 S: + PDE4OTYuNjk3MTcwOTUyQHBvc3RvZmZpY2UucmVzdG9uLm1jaS5uZXQ+
4 C: dGltIGI5MTNhNjAyYzdlZGE3YTQ5NWI0ZTZlNzMzNGQzODkw
5 S: A0001 OK CRAM authentication successful
.xE
.sP
The second message from the server (message 3)
is the base-64 encoding of the string "<1896.697170952@postoffice.reston.mci.net>". This string must be in the form of an RFC 822 msg-id [RFC822] 
and is intended to be globally unique. 
The client's response (message 4) is computed using
HMAC-MD5(password,challenge) and then base-64 encoded for transmission
in message 4.
.sP
CRAM-MD5 is an improvement on the password-in-the-clear mechanisms
that it replaces but still has all the security flaws of basic
challenge/response mechanisms. In particular, it is vulnerable to
post-authentication hijacking and is strongly password equivalent.
.sP
CRAM-MD5 has some interesting security properties with respect to
server password file compromise. The RFC encourages servers
to store a pre-initialized HMAC context rather than than the
client's password. Since the password has already gone through
the MD5 compression function, it is believed to be infeasible
to recover the password from the context. 
However, since the HMAC context is sufficient to compute any
response without knowing the key, an attacker who recovers the
context can impersonate the client without knowing the key.
This context will be the same for all servers which share
the same password. 
The result of these facts is that an attacker who recovers
the password file from such a server can attack any other server
which (1) uses CRAM-MD5 and (2) has a user with the same
password. However, it cannot attack other users with the same
password on machines with a different authentication mechanism
(since that would require direct access to the password
rather than the HMAC context).
.eP
.eP
.nS 2 "Case Study: HTTP Digest"
.sP
HTTP Digest Authentication [RFC2617] is a replacement for HTTP's [RFC2617]
notoriously weak Basic Authentication mechanism, which used passwords
in the clear. Digest Authentication is a challenge/response mechanism
with some additional features to prevent hijacking attacks and
remove strong password equivalence, as well as to reduce round trip
time for multiple requests.
.sP
The basic Digest Authentication interaction takes two round
trips. In the first, the client requests some document and
is rejected. The server's rejection (a 401 Unauthorized) 
contains an indication that it supports Digest Authentication,
a realm string, and a random challenge. The client's subsequent
request includes a message digest over the password, the
challenge, and part of the HTTP Request.
.sP
HTTP Digest offers two types of integrity check (the field
specifying them is called "qop" for 
quality of protection). The "auth" scheme
covers only the request URI. The "auth-int" scheme protects the
URI and the message body, but not the message headers since they
may be changed in transit by proxies or other intermediaries.
Negotiation of the qop is simple: the server offers a set of
acceptable qop values and the client chooses one. 
.eP
.nS 3 "Message Integrity"
.sP
As previously noted, simple challenge/response schemes without
associated channel security allow an attacker to hijack the
connection after authentication has occurred. Since each HTTP
request must be individually authenticated,
an attacker who takes over the channel cannot transmit
new unauthenticated requests over that channel. However, an attacker
might attempt to intercept an authenticated request and mount a
cut-and-paste attack, leaving the authenticator but changing
the contents. This attack is prevented by including the 
URI in the message digest.
.sP
Unfortunately, the URI isn't the only piece of security relevant
information in the HTTP request. Both the headers and the body
are potentially sensitive. For instance, if HTTP POST is used,
FORM input values will be in the message body. The auth-int
qop value protects this information, but it is not widely deployed.
None of the qop values protects the headers.
.sP
It's worth noting that Digest provides protection only for
the request. No authentication is provided for the server,
nor is message integrity provided for the response. It's 
technically possible to provide this feature using a shared
key, as is done in S-HTTP [S-HTTP], but Digest doesn't do so.
.sP
Digest deployment has been somewhat spotty. Fr instance,
the popular Netscape Navigator 4 versions did not support
it.
The fact that there have recently been some
reports of incompatibilities between various implementations
suggests that only minimal testing has so far occurred.
Note that SIP [SIP] requires Digest authentication
and a fair amount of testing has occurred there.
.eP
.nS 3 "Replay Attack"
.sP
Many HTTP requests are idempotent. In such cases, replay attacks
are not a problem since the attacker doesn't get any information
that he would not get by sniffing the original request. However,
many HTTP transactions have side effects and in such cases
preventing replay is important. Unfortunately, the conventional 
approach of requiring a separate challenge/response exchange
for each authentication would double the number of round-trips
for each transaction.
.sP
HTTP Digest provides two features to avoid these round trips.
First, the server can provide a new nonce in a response header.
This nonce must be used for the next client request. This
feature interacts poorly with request pipelining so HTTP Digest
also allows the client to issue multiple requests using a given
server challenge by using  a request sequence number (the
"nonce-count"). 
.eP
.nS 3 "Downgrade Attack"
.sP
HTTP Digest suffers from two types of downgrade attack. In the
first type of attack, the attacker forces the peers to agree
on Basic authentication rather than on Digest. There is no
realistic way to protect against this attack, other than
simply refusing to accept Basic at all.
.sP
In the second Downgrade attack, the attacker forces the peers
to negotiate a qop of "auth" instead of "auth-int". The
downgrade attack would then presumably be followed by an
integrity attack on the client request. This attack could
be prevented by requiring the client to include a digest of
the server's offered qop values in the client's authenticator.
However, that is not the case with the current scheme.
.eP
.nS 2 "List of Challenge-Response Systems"
.sP
.nf
APOP [RFC1939]
HTTP Digest [RFC2617]
AKA [AKA]
CRAM-MD5 [CRAMMD5
Kerberos password-based authentication [KERBEROS]
.fi
.eP
.nS 1 "Anonymous Key Exchange"
.sP
All three of the mechanisms mentioned so far can be hardened 
against passive attacks by the use of anonymous key exchange.
Essentially, the peers arrange for a secure
channel using a key establishment mechanism that does not
authenticate either side. Public key algorithms such as
Diffie-Hellman and RSA can be used in this way.
Once the key is established you can encrypt all the traffic.
and any data which
is transmitted over the channel is secure from eavesdroppers.
This includes data such as passwords or authenticators.
.sP
The problem with this system is that it's subject to what's called
a man-in-the-middle (MITM) attack. Because the cryptographic
key establishment mechanism is unauthenticated, it is
possible for an attacker to intercept communications between
the peers (say Alice and Bob) and pose as Alice to Bob and Bob
to Alice.
The attacker can then forward traffic between them
and get access to whatever's being encrypted.
.sP
The MITM attack on Diffie-Hellman key exchange is shown
in the following figure. Yc, Ya, and Ys are used to denote
the client, attacker, and server public keys respectively.
.eP
.xS
Client                Attacker                Server
------                --------                ------
Yc ->          	   
                         Ya -> 
                                               <- Ys
                      <- Ya
.xE
.sP
At the end of this exchange the client thinks that the
server's public key is Ya and the server thinks that the client's
public key is Ya. However, in reality both have established a
shared secret with the attacker.
.sP
This attack
cannot be detected with CRYPTOGRAPHICALLY authenticating
at least one side of the connection.
Thus,
how much security you believe that anonymous key exchange adds
to your protocol depends on your threat model. 
Active attacks are generally more difficult
to mount than passive attacks but by no means impossible [SECPROB].
.sP
All of these mechanisms use public key cryptography to perform
the initial anonymous key exchange. As a result, 
performance can be unacceptably slow if one side
(e.g., a handheld device) is heavily
constrained. Most Internet servers are fast enough to keep
up with the normal number of required authentications and
hardware acceleration solutions are readily available.
.eP
.nS 2 "Case Study: SSH Password Authentication"
.sP
Secure Shell (SSH) provides a number of authentication
mechanisms, but the first step is always to establish
a secure channel between the client and the server. SSH
is designed not to require certificates: the server
merely provides a raw public key to the client. As a countermeasure
to man-in-the-middle attack, the SSH client caches the server's
public key and generates a warning or error (depending on the
implementation) if that key changes. 
.sP
In theory, caching the public key protects against MITM attack
at any time other than the initial connection to the server.
In practice, when users encounter the error that the key
has changed, they often simply override the warning or delete
the cache entry when the error occurs, assuming, correctly,
that the likely case is that the server administrator
has just reset the public key (e.g. by reinstalling the
software without preserving the old key).
.sP
A very careful user can obtain complete security against MITM
attacks by obtaining the server's key fingerprint (a message
digest of the key) out of band and comparing that to the 
fingerprint of the key the server offers.
.sP
SSH bootstraps off of the system's login mechanisms so it will
support either passwords in the clear or one time password
authentication. Note that in either case if an attacker
mounts a successful man in the middle attack, he will be
able to hijack the connection post-authentication, just
as he would have if the transaction was performed in
the clear. This vulnerability can be alleviated with careful
protocol design, as we'll see in the next case study.
.eP
.nS 2 "List of Anonymous Key Exchange Mechanisms"
.sP
.nf
SSH (password mode) [SSH]
SSL/TLS (anonymous keying) [TLS]
.fi
.eP
.nS 1 "Zero-Knowledge Password Proofs"
.sP
All of the mechanisms mentioned so far depend on some sort of shared
key. If that shared key is a user-derived password, then it's 
possible for the attacker to mount an offline dictionary attack
on the password, either completely passively (as with 
CRAM-MD5) or with a single MITM attack (as with TLS anonymous
DH). However, a rather clever class of protocols known as
Zero Knowledge Password Proofs (ZKPPs) makes it possible
to use user-generated passwords without fear of offline
dictionary attack
.sP
The earliest (and simplest) ZKPP is EKE [EKE], designed by
Steve Bellovin and James Merritt. EKE is based on Diffie-Hellman,
but instead
of sending the key shares (the public keys) in the clear
they are encrypted using a password. 
The protocol looks like this.
.eP
.xS
Client						Server
------						------	
Name, E(Password, Ya)) ->
                  <- E(Password, Yb),E(K,Challenge-b)
E(K,Challenge-a || Challenge-b) ->
                  <-                E(K, Challenge-a)

Where K is the DH shared secret == g(Xa * Xb) mod p
.xE
The first two messages basically establish a Diffie-Hellman
shared secret. The next two messages encrypting the challenge
values are used to prove that the two peers have negotiated
the same shared secret key. The reason this works is that
an attacker who does not know the password will get the 
wrong value when he decrypts the other side's public key.
When he computes the DH shared secret, he will get a different
value from the peer he is talking to and the Challenges
will not decrypt correctly. 
.sP
Note that EKE as described above is insecure against password
file compromise, since the server must store the password.
Augmented EKE [A-EKE] describes a protocol that is secure
against this. A large number of other ZKPPs have been 
proposed, including PDM [PDM], SPEKE [SPEKE], and SRP[SRP].
These protocols are all roughly equivalent, offering slightly
different combinations of security, performance, and message
count.
.eP
.nS 2 "Intellectual Property"
.sP
From a technical perspective, ZKPPs dominate the anonymous key exchange
mechanisms described in Section 7. Their performance is roughly
equivalent and their security guarantees are superior.  The major
ZKPPs are EKE, A-EKE, SPEKE, and SRP.
there are a number of Intellectual Property Rights in this area, some
of which are on
file with the IETF (www.ietf.org/ipr).
.eP
.nS 2 "List of Zero Knowledge Password Proof Systems"
.sP
.nf
EKE [EKE]
A-EKE [A-EKE]
PDM [PDM]
SPEKE [SPEKE]
SRP [SRP]
.fi
.eP
.nS 1 "Server Certificates plus User Authentication"
.sP
If you can authenticate one side of the connection (typically
a server) then it becomes far easier to provide strong
authentication. Anonymous key exchange, cleartext passwords,
one time passwords, and challenge/response protocols can all
run over an authenticated and encrypted channel. In such
a system, there's no need to worry about active attack, so
the authentication protocols don't need to be hardened
against it.
.sP
Providing an encrypted channel with authentication for the server
dramatically reduces the security advantage enjoyed by more complicated
schemes over simple passwords. Since the marginal security benefit of
such systems is so modest when compared to the increased implementation
and deployment complexity, common practice when server authentication
is available is to use simple passwords over the encrypted channel. 
This includes systems such as passwords over SSL and passwords over
IPsec VPNs.
.sP
In addition to making the overall authentication problem simpler,
hosting one's application protocol over an encrypted and authenticated
channel has a number of other security benefits. First, a properly
designed channel security protocol removes the threat of post-authentication
hijacking (described in Section 4.2). Second, it provides confidentiality
and message integrity for the rest of the application traffic, which
is in general a good thing.
.sP
The primary difficulty with this approach is that providing certificate-based
server authentication is not straightforward. The first problem is
that the server machine must have a certificate, which entails some
inconvenience and cost. Self-signed certificates aren't acceptable
in this case (rather, they reduce you to the anonymous key exchange
scenario described in Section 7). 
.sP
The more serious problem is establishing what the server side
name in the certificate ought to be. Common practice (stemming
from practice in HTTPS [HTTPTLS]) is to have the server's certificate
contain the server's fully qualified domain name (FQDN), either
in the Common Name or subjectAltName fields, but this is unacceptable
if the server does not have a domain name. One can also put the
server's IP address in the subjectAltName, but this is inappropriate
if that IP address might change. Any protocol which uses this mechanism
MUST specify a mechanism for determining the server's expected domain
name.
.sP
One concern here is what happens if the server has a certificate
that has the wrong name or that is signed by a Certificate Authority
that the user's client does not recognize. Many such clients
present a dialogue warning the user that the connection may
be under attack and offering to let him ignore the error. 
Obviously, if users do this routinely (and it is widely 
believed that they do) then they can be subject to an active
attack.
.eP
.nS 2 "Case Study: Passwords over HTTPS"
.sP
Despite the existence of Digest Authentication, the dominant form
of strong HTTP authentication is passwords with HTTP over SSL (HTTPS).
As mentioned above, this mechanism has superior security properties
to Digest (provided that the server has a real certificate) and
is easier to deploy, especially if the server wants to use SSL/TLS
for channel security in any case.
.sP
There are actually two ways to use passwords over HTTPS. The first
is to use HTTP's built in authentication mechanisms (either Digest
or Basic) over an HTTPS connection. The second is to perform
password authentication at the application layer, using an HTML form
to prompt for the password. The form method is far more popular, 
primarily because it allows the application designer far greater
control over when and how authentication occurs. In particular, the
designer can give the password dialog any look he chooses.
.sP
In general, if form-based authentication is used, the only available 
option is to use simple passwords, since HTML has no facilities for
performing arbitrary computation or challenge/response passwords.
Theoretically, one could perform these operations in a JavaScript 
or Java program, but in practice this is generally not done.
.eP
.nS 3 "Authentication State"
.sP
When Basic or Digest Authentication is used, the client can
simply transmit an authenticator with every request. However,
if authentication is performed using an HTML form, this approach
is impractical, since it would require client interaction for
every page fetch. Three approaches for solving this problem are
generally proposed.
.sP
.nS 4 "The Token Problem"
.sP
In general, all HTTP authentication state carrying schemes involve 
providing the client with some token which it can then present
to authenticate future requests. This token must be constructed
in such a fashion that it is impossible for the client to
tamper with it and obtain access to resources that they would
not otherwise be able to access.
.sP
There are two basic techniques for constructing tokens. The first is
to have the token be self-authenticating, e.g. by having it
be the user's information signed or MAC-ed with a key known only to
the server. The second is to have it be an index into some database
of authenticated users stored on the server. Note that these indices
must be unpredictable to prevent one user from guessing another
user's token. 
The self-authenticating
approach has the advantage that it does not require persistent
storage on the server but the disadvantage that there is no way
to mark a token invalid or update it (although they can of course contain an
expiry time). When multiple servers are involved, self-authenticating
tokens have the additional advantage that they do not require
inter-server communication.
.eP
.nS 4 "URL Rewriting"
.sP
The most general but also most difficult approach is to dynamically
rewrite all URLs provided to the client after authentication has 
occurred. One might, for instance, pass all pages through a CGI
script, where the arguments include the real page to be accessed
and the authenticator token. an example of such a URL is:
.eP
.xS
http://www.example.com/cgi-bin/gw.pl?authenticator
	=MjFkNWQyOGRjYjlmM2IwMmJjMzk0NGFhODg0YTQ4YTcK?page=foo.html
.xE
.sP
The CGI script would then use the authenticator argument to determine
the client identity, recover the actual target page and perform the
authentication checks. Using a CGI script this way is inconvenient since
it requires replicating the server's access control infrastructure.
A less intrusive approach involves having a server plugin unwrap
the target URL early in the server's processing pipeline, before
the access control checks are performed. This allows the server to
perform its normal authentication checks based on the unwrapped
identity.
.sP
The primary difficulty with URL rewriting is that it all
pages must be dynamically generated. Either each page must
be generated by a script which embeds the appropriate URLs
or the server must postprocess pages to embed them. Either
approach makes the system more complex and therefore adds
instability. However, before the introduction of cookies,
URL rewriting was essentially the only option for token passing.
.eP
.nS 4 "Cookies"
.sP
The inconvenience of URL rewriting lead to the introduction
of HTTP Cookies [RFC 2109]. Essentially, an HTTP cookie is a token
issued by the server and transmitted by the client with requests.
The cookies can be labeled to be transmitted only when resources
matching various prefixes are dereferenced, including resources
on another server.
Browsers generally persistently cache cookies between invocations.
Cookies are the method of choice for carrying HTTP state information
and can be used to carry all kinds of state besides authentication
information. Note, however, that since cookies can be used to transmit
information from
one server to another, they have been the focus of privacy concerns
[RFC2965]. Accordingly, some users choose not to accept or transmit cookies.
.sP
Note that RFC 2964 [RFC 2964] specifically recommends against
the usage of cookies for carrying authentication and authorization
information. Nevertheless, this practice is nearly universal on
the Web.
.eP
.nS 4 "HTTPS Session Binding"
.sP
Each TLS/SSL session has a session identifier, which is used for
resuming the session without a full handshake. These session IDs are
unique for any given server, so server administrators often think
to use the session ID as a search key for the user's information. 
This is a bad idea. The fundamental problem is that there's no
guarantee that any given session will be resumed. The client need
not offer to resume a session and the server need not accept, or may
flush its session cache at any time. Thus, using the session ID as a 
persistent identifier is unwise.
.eP
.nS 2 "List of Server Certificate Systems"
.sP
.nf
HTTP over TLS (HTTPS) [HTTPTLS]
SMTP over TLS [STARTTLS]
XMPP over TLS [XMPP]
IPsec (under some conditions) 
.fi
.eP
.nS 1 "Mutual Public Key Authentication"
.sP
If both client and server have certificates, then the peers can use
mutual certificate authentication. This is done by having both client
and server establish that they know the private keys corresponding to
their certificates. A wide variety of protocols offer this functionality,
including SSL, IPsec, and SSH (SSH actually offers mutual authentication
with pre-arranged public keys).
.sP
The two most important advantages of public key authentication are
that it has no password equivalence and that it can allow authentication
between parties who have no prior arrangement.
.eP
.nS 2 "Password Equivalence"
.sP
With public key authentication, the server knows only the client's
public key. It is therefore incapable of forging any kind of authentication
message from the client. Similarly, knowledge of the public key does
not allow an attacker to authenticate to the server. Accordingly,
public key techniques never store a password equivalent on the server.
.eP
.nS 2 "Authentication between Unknown Parties"
.sP
One advantage of certificate-based public key authentication systems
\*-as opposed to those using pre-arranged public keys\*-is that 
it allows authentication between parties who have had no prior contact.
Authentication of servers with which one has had no prior arrangement
happens all the time in the HTTPS context: the user wishes to connect
to a host at a given URL and is able to verify that the server certificate
matches that URL. 
.sP
In addition to strict identity verification, it's possible to use
certificates to carry authorization information. This allows a
central authority to make both authentication and access control
decisions for distributed servers merely by issuing certificates.
[POLICYMAKE] describes such a system.
.eP
.nS 2 "Key Storage"
.sP
The primary security problem with public key authentication protocol
(assuming the basic protocol is designed correctly) is protecting the
private key. In server applications and many non-mobile client
applications, the key is simply stored on disk, often encrypted
under a password-derived symmetric key.
In applications where the user must carry his authentication information
around, this can be done in essentially two ways: with
a token or by generating the key from a password. 
.eP
.nS 2 "Tokens"
.sP
The general idea of a secure token is relatively simple: you have
a tamper-resistant and portable token which carries your private
key (and probably your certificate). The token can be interfaced
to a computer, typically through a USB jack or a smartcard interface.
The private key is generally protected by a PIN, but of course
this PIN is known to any computer on which the token is used,
since the PIN is sent to the token by the computer. The primary
threat to tokens is loss or theft. It's not generally economical to
make such tokens completely tamper-proof, so a lost token in
the hands of a dedicated attacker means a lost private key.
.sP
There are two major types of tokens: those which are pure memory
for key storage and those which do the cryptography on the token.
The first are substantially cheaper but less secure because they
give the key to the host computer.
.eP
.nS 2 "Password Derived Keys"
.sP
It's generally possible to derive a user's private key from a 
relatively short password, simply by using the password to
seed a cryptographically secure PRNG which is used to generate
the private key. Unfortunately, this technique is susceptible
to dictionary attack, since an attacker can dictionary search
the password space until he finds a password that generates
a key pair that matches the signature. Protocols can be
designed to resist this attack by exchanging the signed
client response under the server's private key, but many protocols
(notably SSL) do not. Accordingly, password derived keys should
be viewed as a mechanism for using shared keys with public-key-only
protocols, not as a fully public key system.
.eP
.nS 2 "Case Study: SMTP over TLS"
.sP
.sP
SMTP can be combined with TLS as described in 
[STARTTLS].
This 
provides similar protection to that provided when using IPSEC. 
Since TLS certificates typically contain the server's
host name, recipient authentication may be slightly more
obvious, but is still susceptible to DNS spoofing attacks. Notably,
common implementations of TLS contain a US exportable 
(and hence low security) mode. Applications desiring high
security should ensure that this mode is disabled.
Protection is provided against replay attacks, since
the data itself is protected and the packets cannot be replayed.
.eP
.nS 2 "List of Mutual Public Key Systems"
.sP
.nf
SSL/TLS (client auth mode) [TLS]
IPsec IKE [IKE]
S/MIME [s/MIME]
.fi
.eP
.nS 1 "Generic Authentication Mechanisms"
.sP
An approach that has lately gained currency is to use a generic
authentication negotiation system. Examples of such systems include
SASL [SASL] and EAP [EAP]. The general idea is that one has a protocol
framework which doesn't provide any authentication features per
se but instead allows you to negotiate the authentication mechanisms
you wish to use. SASL, for instance, allows the negotiation of 
CRAM-MD5 (a digest-based challenge/response mechanism), SRP, and TLS
among other mechanisms.
.sP
Generic authentication mechanisms are attractive to application
protocol designers because they allow them--in theory--to add security
to their protocols without having to directly deal with the security
issues. They simply specify that one should use a given framework.
They're attractive to security mechanism designers because it's
relatively easy to add new mechanisms.
.eP
.nS 2 "Downgrade Attacks"
.sP
The most serious problem with generic authentication mechanisms is
their susceptibility to DOWNGRADE ATTACK, in which the attacker
interferes with the negotiation to force the parties to negotiate
a weaker mechanism than they otherwise would. Consider a set of
peers, each of which supports both challenge/response and simple
passwords. An attacker can force them into using a simple password
and then capture that password. 
.sP
The standard countermeasure to downgrade attack is to authenticate
a message digest of the offered mechanisms. Unfortunately, this
protection is only as strong as the weakest common mechanism. 
If this mechanism is a simple password then no protection against
downgrade attack is possible. 
The possibility of downgrade attack requires that users of 
generic security mechanisms carefully profile the mechanisms they
offer to ensure that they are all adequately strong.
.eP
.nS 2 "Multiple Equivalent Mechanisms"
.sP
The ease of adding new security mechanisms to generic authentication
layers means that a given authentication layer may have a number of
different mechanisms with essentially similar characteristics. For
instance, SASL has mechanisms for SecurID [RFC 2808], OTP [RFC 2245], 
and Digest Authentication [RFC 2831]. In addition, there is currently
an Internet-Draft for CRAM-MD5 support in SASL. These methods offer
fairly equivalent security (with the major exception being the
password equivalence issue for the challenge response mechanisms).
.sP
So, why the proliferation of superficially redundant mechanisms? From
a security perspective, they could all be replaced by Digest. The
reason appears to be legacy authentication mechanisms. Many environments
already have S/Key or SecurID installed and the administrators
don't want to replace them. This inevitably creates pressure to
add every conceivable security mechanism to one's generic framework.
.sP
While the desire to support legacy authentication systems is
understandable, it should be resisted to the extent possible. Having
multiple equivalent mechanisms dramatically increases both
implementation complexity and interoperability problems. When 
designing a new system, designers should choose a very small
number of authentication mechanisms, with no more than one
of any given class.
.eP
.eP
.nS 2 "Excessive Layering"
.sP
Many of the legacy authentication mechanisms that users and 
administrators wish to support are themselves generic frameworks
of one kind or another. For instance, SASL allows the use of
GSSAPI, which itself is a generic framework for a number of 
mechanisms. This sort of layering dramatically increases
both implementation and deployment complexity. For instance,
GSSAPI contains mechanisms that are essentially equivalent
to Kerberos, but SASL also supports Kerberos directly. Under
what conditions should clients use Kerberos directly and under
which should they use it through GSSAPI?
.sP
Another example of the same problem is the Extensible Authentication
Protocol (EAP) [EAP], an authentication framework originally designed for
PPP [PPP]. Note that PPP itself allows multiple authentication
mechanisms, so PPP must first negotiate EAP. EAP then negotiates
the individual mechanisms. To make matters worse, one of the
EAP mechanisms is TLS [TLS] which can negotiate its own
authentication mechanisms. Three levels of indirection seems a bit
much.
.sP
In accordance with the principle of having as few mechanisms as
possible, frameworks should avoid mechanisms that are themselves
frameworks, in favor of using the second framework's mechanisms
directly. "We'll build ours on top of theirs" is a bad policy.
.eP
.nS 2 "List of Generic Authentication Systems"
.sP
.nf
GSS-API [GSS-API]
SASL [SASL]
EAP [EAP]
.fi
.eP
.nS 1 "Sharing Authentication Information"
.sP
In many cases, users will use the same authentication data for 
a large number of services. For instance, users may expect to
use the same username/password pair for TELNET, IMAP, and FTP.
In such cases, it is generally desirable for all such services
to share a single set of authentication data. For instance, 
TELNET, IMAP, and FTP typically all share the same password database. 
.eP
.nS 2 "Authentication Services"
.sP
This problem is made more difficult if the services which must
share authentication data reside on different machines. This
problem is typically solved (when it is solved, as opposed to
simply ignored) by having some unique system which
has the credentials. Such a machine may either provide authentication
as service (as in Kerberos) or simply provide credentials to
authorized machines (YP, NIS). In either case, this protocol
needs to be secured. 
.eP
.nS 2 "Single Sign-On"
.sP
A related problem is that users don't necessarily want to 
have to manually authenticate each time some service wants 
authentication. Rather, they want to authenticate once
and have software take care of the rest. This capability is called
SINGLE SIGN-ON.
If all authentication will be performed by
one program, this can be fixed simply by having the program
cache the user's credentials. If credentials need to be shared
across multiple services then it's necessary to have some
way to pass them from the program which first authenticates
to others (or to have some central credential manager).
This service is generally called SINGLE SIGN-ON.
.pP
As a special case, consider the case where mutually suspicious systems
all want to allow a user to authenticate with a single set of
credentials. If certificate-based authentication is being
used, this is relatively straightforward. In the case where
passwords are being used, the typical solution is to have
some third party authentication service which authenticates
the user and then vouches for the user to the services. 
Microsoft Passport is one
such provider.
.eP
.nS 2 "Case Study: RADIUS"
.sP
RADIUS is a remote authentication service commonly used for network
attachment points. Many network access points are relatively constrained, untrusted devices. Thus, it's convenient for them not to
perform authentication directly. Instead, authentication is done by
an authentication server.
.sP
When a client contacts the attachment point, the attachment point
contacts that authentication server for authentication. It proxies
the authentication handshake between the authenticating client and
the authentication server. RADIUS is a generic protocol which can
tunnel a large number of authentication protocols. No matter what the
protocol, when the handshake has finished, the attachment point knows
the client's authenticated identity.
.eP
.nS 2 "Case Study: Kerberos"
.sP
Kerberos [KERBEROS] is a popular authentication/single sign-on service,
especially in
academic environments. Kerberos is based on the Needham-Schroeder
authentication protocol. The authentication server role is
played by a Key Distribution Center (KDC). When a client first
signs on the client proves its identity to the KDC, usually
by means of a password shared with the KDC.
.pP
Kerberos is unusual in that the 
authentication service is provided to the client rather
than the server. When a client wishes to communicate
with a server, it first contacts the KDC and acquires a 
TICKET. That ticket contains a new symmetric key encrypted
for both the client and server. The client can transmit the
ticket to the server and use it both to prove its identity
and establish a secure channel.
.eP
.nS 2 "List of Authentication Server Systems"
.sP
.nf
Kerberos [KERBEROS]
RADIUS [RADIUS]
DIAMETER [DIAMETER]
.fi
.eP
.nS 1 "Guidance for Protocol Designers"
.sP
Adding authentication to protocols is difficult and is made even
more difficult by the large number of options. This section
attempts to provide some guidance to protocol designers. No
single document can tell you how to build a secure system, but
the following guidelines provide generally good advice. If
you feel you need to violate one of these rules of thumb,
make sure you know why you're doing it.
.eP
.nS 2 "Know what you're trying to do"
.sP
The first thing to do is figure out what the security
problem you're trying to solve is. Questions to ask include:
.eP
.nS 3 "What's my threat model?"
.sP
Sorting out the threat model is always the first step in deciding
what sorts of security mechanisms to use. In the case of authentication
you must consider, at minimum.
.eP
.xS
1. What will be the result of various forms of attack?
2. Does the threat model include active attack. (Hint: it should.)
3. Do I need protection for my data or just the authentication.
   (Hint: probably you do).
4. How valuable is the data being secured? Are exhaustive computational
   attacks practical?
5. How competent are my users going to be?
.xE
.nS 3 "How many users will this system have?"
.sP
In general, the difficulty of managing a system scales with (or greater
than) the number of users. This means that mechanisms which are practical
with a small number of users may simply have too much overhead with
a large number of users. For example, many token-based solutions charge
by the token, which may be a prohibitive expense if there are many users.
.eP
.nS 3 "What's my protocol architecture?"
.sP
In some systems (e.g. POP, IMAP, TELNET), clients connect directly
to the server. In others (e.g. HTTP, SIP, RSVP, BGP), authentication
may need to be established over multiple hops when the entities
have no independent authentication. Each case requires a different
strategy. See Section 13.1.3 for more discussion on this topic.
.eP
.nS 3 "Do I need to share authentication data"?
.sP
If authentication data needs to be shared, especially between multiple
servers, it's generally worth considering some sort of authentication
server or using certificates.
.eP
.nS 2 "Use As Few Mechanisms as You Can"
.sP
Preferably, systems should have only one form of authentication.  The
more methods of authentication a system allows, the more things there
are to go wrong.  Remember that a chain is only as strong as
its weakest link.
In general, there are two reasons why systems allow
more than one authentication mechanism. The first is that you're
retrofitting a system which already has a large number of
authentication mechanisms which cannot be displaced. The second is
that users have widely different environments which for some reason
cannot use the same authentication mechanism conveniently (e.g. some
users have tokens and some do not).
.sP
Naturally, designers need to take such considerations into account
but they should take reasonable steps to minimize the number
of mechanisms. Designers should take special care to minimize
the number of equivalent mechanisms. For instance, a system
that provides a challenge/response mechanism and a public key based
mechanism is a reasonable design, one that provides three different
challenge/response mechanisms is not.
.sP
This doesn't mean that designers should not use security frameworks
where multiple mechanisms are appropriate, but it does mean
that they should be avoided unless necessary. Where generic security
frameworks are used, they supported mechanisms should be carefully
profiled to a minimal set.
.eP
.nS 2 "Avoid simple passwords"
.sP
It's widely known that simple plaintext passwords are unsafe, but
what's less widely known is that merely providing such a 
scheme can weaken systems even
if stronger mechanisms are present. Consider the case where
a system uses a negotiation framework that allows passwords. A downgrade
attack can force the user to reveal his password even if both
client and server support stronger mechanisms. Accordingly,
designers should avoid deploying simple password mechanisms
if at all possible, not just provide stronger mechanisms.
.eP
.nS 2 "Avoid inventing something new"
.sP
Despite the large number of mechanisms we've discussed, this
document describes only a small number of the available
authentication mechanisms. There are very few situations in
which designers cannot use some preexisting mechanism. This
is vastly preferable to designing their own version of one
of the standard mechanisms. In particular, designers should
avoid designing their own channel security systems. If you
want a channel security system, use IPsec or TLS.
.eP
.nS 2 "Use the strongest mechanisms you can"
.sP
Having the strongest security you can apropos is generally a good plan.
It's particularly good advice here, since passwords in the clear,
one-time passwords, challenge-response and zero-knowledge password
proofs all require the user to have the same kind of credential: a 
password. (Note that some OTP schemes such as SecurID require a token.)
When designing a new system, the ability to provide a familiar
interface to a user is valuable, minimizing additional work
for client and server implementors is not.
NIST Spec. Pub. 800-63 [800-63] provides good guidance
about the minimum requirements for various applications.
.eP
.nS 2 "Consider providing message integrity"
.sP
Although most of the authentication mechanisms we've described
are themselves resistant to active attacks, many are subject
to hijacking after authentication has completed. If your
threat model includes active attack (it should), you should
strongly consider providing message integrity for all of your
protocol messages in order to prevent hijacking.
.eP
.nS 1 "Scenarios"
.sP
Despite the proliferation of authentication mechanisms, there
are generally one or two optimal mechanisms for each scenario.
We attempt to describe those mechanisms here. This section is
divided into two parts, attacking the problem from different
angles. In the first, we consider the various kinds of capabilities
entities might have and the best mechanisms to use with those
capabilities. In the second part we discuss a number of different
protocol architectures and the potential mechanisms which can
be used with those architectures.
.eP
.nS 2 "Capability Considerations"
.sP
There are three primary authentication scenarios:
.nf
(1) Neither side has a public/private key pair.
(2) One side has an authenticated key pair (either via a
certificate or prior arrangement).
(3) Both sides have authenticated key pairs
.fi
.sP
Despite the proliferation of authentication mechanisms, there 
are only one or two best mechanisms for each scenario. We describe
them here.
.eP
.nS 3 "Neither side has a public/private key pair"
.sP
Three basic strategies are suitable for the situation where
neither side has a key pair: challenge/response, one-time passwords,
and ZKPPs. The only situation in which OTP systems are superior
to challenge/response systems is when adapting a legacy system
in which it is difficult to change the client software. If the
client software can be changed, challenge/response offers roughly
equivalent security with significantly less management complexity.
ZKPP proofs are technically superior however, in at least
two cases (SACRED and IPS), IETF
WGs have chosen not to require ZKPPs due to IPR concerns.
.sP
These considerations make challenge/response the best choice
for this scenario. If at all possible, it should be performed under
cover of an anonymous key exchange, as described in section 7.
With this adaptation, an attacker needs to mount an active attack
in order to dictionary search the password space.
.eP
.nS 3 "One side has an authenticated key pair"
.sP
If the server has a key pair which the client can authenticate,
then simple username/password encrypted under the server's
public key is the preferred authentication
mechanism. Rather than encrypting directly under the server's
public key, the standard practice here is to use the server's
key to establish a secure channel and then pass the password over
that channel. Challenge/response is in fact weaker in this case
because it is is password equivalent. Once confidentiality is
provided, OTP and ZKPP systems offer significant additional management
complexity for marginal security benefit. 
.eP
.nS 3 "Both sides have authenticated key pairs"
.sP
If both sides have key pairs, the optimal mechanism is mutual
public key authentication.
.eP
.nS 2 "Architectural Considerations"
.sP
In this section, we consider 3 different network architectures
and the authentication mechanisms that are most suitable for each.
.eP
.nS 3 "Simple Connection"
.sP
The simplest authentication scenario is where the peers
are connected by some interactive connection. Mercifully, this
situation is quite common in such protocols as IMAP, TELNET, etc.
In this simple case, mostly any authentication mechanism
can be employed and so the choice depends on other factors, such as
what credentials are available and the degree of security required.
.eP
.nS 3 "Proxied Client/Server"
.sP
It's quite common for client/server communication to be propagated
through some gateway, as happens with HTTP. This situation has two
potential authentication problems.
.eP
.xS
1. How does the client authenticate to the proxy so that the
   proxy knows to serve it.
2. How does the client authenticate to the server with the
   proxy in the way.
.xE
.sP
The problem of authenticating to the proxy looks essentially
like the ordinary client/server authentication problem (except
in the case where there are multiple proxies in which case
authenticating to anything other than the first hop proxy looks
rather like problem 2.) 
.sP
The problem of authenticating through
the proxy is rather more difficult.
The obstacle is that either client nor server may 
not trust the proxy and they do not want to involve it in
their authentication. They therefore need to provide an authentication
method (preferably with message integrity) that doesn't require
trusting the proxy. This rules out simple passwords and makes
one-time passwords extremely questionable.
There are three basic strategies available. 
.eP
.nS 4 "Tunnel"
.sP
If the client and the server establish a tunnel through the proxy
then they can behave as if this was an ordinary client/server 
transaction. Although this rather obviates the point of having
a proxy, it's still a popular strategy and is used with HTTPS [HTTPTLS].
Since the proxy is untrusted, the application protocol must either
be run over a secure channel or hardened against active attacks.
.eP
.nS 4 "Challenge/Response"
.sP
A shared symmetric key between client and server can be used for
authentication even in the face of a proxy by using standard
challenge/response methods (with appropriate protocol modifications
to distinguish between protocol data units (PDUs)
directed towards the proxy and those
directed towards endpoints.) These methods should include integrity
protection for the individual PDUs.
.sP
On a small scale, this technique works (it's what's used in HTTP
when HTTPS is not used) but it quickly becomes unwieldy. If there
are a large chain of proxies each of which wishes to authenticate
the client, server, other proxies or all three, an enormous number
of pairwise keys need to be established and maintained. In a 
protocol where long proxy chains are expected, symmetric key
based authentication is probably impractical.
.sP
A variant of this technique is to use a message-based system
with symmetric keying such as S/MIME. All PDUs can then be 
encapsulated in secure messages. Recursive encapsulation can
be used to provide authentication to proxies. 
.eP
.eP
.nS 4 "Digital Signatures"
.sP
The final approach is to use public-key based digital signatures.
Each endpoint signs each message (possibly with some set of nonces
to prevent replay attack). The disadvantage of this approach is
that it requires a PKI. The advantage is that it doesn't require
pairwise keys. Each proxy in the chain can validate the client
and the server based solely on their signatures.
.eP
.nS 3 "Store and Forward"
.sP
A number of important IETF protocols, most importantly, e-mail,
are of the store and forward messaging variety. Such protocols
have roughly the same security options as proxied protocols
except that tunneling is no longer possible. Additionally,
since store and forward protocols are non-interactive, many of
the usual challenge/response techniques for preventing replay
attack no longer work and so care must be taken to either
make one's system idempotent or introduce a specific anti-replay
mechanism. The standard technique for store-and-forward situations
is message security a la S/MIME.
.sP
.nS 3 "Multicast"
.sP
A number of IETF protocols have the property that multicast or
broadcast message integrity needs to be provided. For example,
routing and DNS both require the ability for a single sender
to broadcast authenticated and integrity protected messages to
a large number of receivers. There are two relevant cases:
In the first, all members of the group are trusted and so
it's feasible to have some group key which is used for authenticating
all transmissions. This group key may be manually configured or
established via some protocol such as GSAKMP [GSAKMP].
.sP
In the second case, individual group members are not trusted not
to forge messages. With such systems, it's not really
practical to use symmetric key systems because the sender would need
to agree on a key with each recipient (there may not even be a
return channel). The only really practical approach in these
multicast situations is for the sender to digitally sign each
transmission with its private key.
.eP
.LP
Acknowledgments
.XS
\*(SN Acknowledgments
.XE
.sP
Early versions of this document were reviewed by Fred Baker, Lisa Dusseault,
Ted Hardie, and Mike St. Johns. Thanks to John Linn and Paul Hoffman
for their comments.
.eP
.LP
Informative References
.XS
\*(SN Informative References
.XE
.in 3
.nf
   [800-63] NIST, "Electronic Authentication Guideline: Recommendations
           of the National Institute of Standards and Technology",
	   Spec. Pub. 800-63, 2004.

   [A-EKE] Bellovin, S.M., Merritt, M., "Augmented Encrypted Key
	   Exchange: a Password-Based Protocol Secure Against
	   Dictionary Attacks and Password File Compromise"
	   Technical Report, AT&T Bell Laboratories, 1994.

   [AKA]  3GPP Technical Specification 3GPP TS 33.102 V5.1.0: 
          "Technical Specification Group Services and System Aspects; 3G 
           Security; Security Architecture (Release 5)", 3rd Generation 
           Partnership Project, December 2002. 

   [CRACK]   Muffet, A., "CRACK v 5.0a",
          http://www.crypticide.org/users/alecm/security/c50-faq.html

   [CRAMMD5] Klensin, J., Catoe, R., Krumviede, P., "IMAP/POP AUTHorize
          Extension for Simple Challenge/Response", RFC 2195,
          September 1997.

   [DIAMETER] Calhoun, P., "Diameter Base Protocol", draft-ietf-aaa-diameter-17.txt.


   [EAP]       Blunk, L., Vollbrecht, J., "PPP Extensible Authentication Protocol
          (EAP)", RFC 2284, March 1998.

   [EAPTLS]  Aboba, B., Simon, D., "PPP EAP TLS Authentication Protocol",
          RFC 2716, October 1999.

   [EKEPR]   Lucent's IPR statement on SRP
             http://www.ietf.org/ietf/IPR/LUCENT-SRP

   [EKE]     Bellovin, S., Merritt, M., "Encrypted Key Exchange:
             Password-based protocols secure against dictionary
             attacks", Proceedings of the IEEE Symposium on Research
             in Security and Privacy, May 1992.
   [GLOSSARY] Shirey, R., "Internet Security Glossary", RFC 2828,
	     May 2000.

   [GSAKMP]  Harney, H., "GSAKMP", draft-ietf-msec-gsakmp-sec-02.txt

   [GSS-API] Linn, J., "Generic Security Service Application Program
          Interface Version 2, Update 1", RFC 2743, January 2000.

   [HMAC]      Krawczyk, H, Bellare, M., Canetti, R., "HMAC: Keyed-Hashing
          forMessage Authentication", RFC 2104, February 1997.

   [HTTPTLS] Rescorla, E., "HTTP over TLS", RFC 2818, May 2000.


   [IKE]       Harkins, D., Carrel, D., "The Internet Key Exchange (IKE)",
          RFC 2409, November 1998.

   [IMAP]    Crispin, M., "Internet Message Access Protocol - Version 4rev1",
          RFC 3501, March 2003.

   [KERBEROS]Kohl, J., Neuman, C., "The Kerberos Network Authentication
             Service (V5)", RFC 1510, September 1993.

   [KLEIN]   Klein, D.V., "Foiling the Cracker: A Survey of
             Improvements to Password Security",  1990.

   [OTP]     Haller, N., Metz, C., Nesser, P., "A One-Time Password
             System", Straw, M., RFC 2289, February 1998.

   [POLICYM] M. Blaze, J. Feigenbaum, and J. Lacy. "Decentralized trust
          management" In Proceedings 1996 IEEE Symposium on Security and
          Privacy, pages 164--173, May 1996.

   [PDM]   Kaufman, C., Perlman, R., "PDM: A New Strong Password-Based
          Protocol", Proceedings of the 10th USENIX Security Symposium,
	  August 2001.
	  
   [PPP]       Simpson, W., "The Point-to-Point Protocol (PPP)",
          RFC 1661, July 1994.

   [RADIUS]  Rigney, C., Rubens, A., Simpson, W., Willens, S.,
          "Remote Authentication Dial In User Service (RADIUS)",
          RFC 2138.

   [RFC1939] Myers, J. and M. Rose, "Post Office Protocol -- Version
          3", STD 53, RFC 1939, May 1996.

   [RFC2617] J. Franks, P. Hallam-Baker, J. Hostetler, S. Lawrence,
          P. Leach, A. Luotonen, L. Stewart "HTTP Authentication:
          Basic and Digest Access Authentication" RFC 2617,
          June 1999

   [RFC2964] K. Moore, N. Freed, "Use of HTTP State Management",
          RFC 2964, October 2000.
   
   [RFC2965] Kristol, D., Montulli, L., "HTTP State Management Mechanism",
          RFC 2965, October 2000.

   [SASL]    Myers, J., "Simple Authenticatin and Security Layer (SASL)",
             RFC 2222, October 1997.

   [SECPROB] Bellovin, S.M. "Security Problems in the TCP/IP Protocol
           Suite", Computer Communication Review, pages 32-48, April 1989. 


   [SECCONS] Rescorla, E., Korver, B., IAB, "Guidelines for Writing
          RFC Text on Security Considerations", RFC 3552.

   [S-HTTP]  Rescorla, E., and Schiffman, A., "The Secure HyperText Transfer
             Protocol",  RFC 2660, August 1999.


   [SIP]     Rosenberg, J., Schulzrinne, Camarillo, G., Johnston, A.,
             Peterson, J., Sparks, R., Handley, M., Schooler, E.,
             "SIP: Session Initiation Protocol", RFC 3261,
             June 2002.

   [SKEY]    Haller, N.,"The S/KEY One-Time Password System",
          RFC 1760, February 1995.

   [S/MIME]  Ramsdell, B., Ed., "S/MIME Version 3 Message Specification",
             RFC 2633, June 1999.

   [SPEKE]   Jablon, D., "Strong Password-Only Authenticated Key Exchange",
             Computer Communication Review, ACM SIGCOMM, vol. 26, no. 5,
             pp. 5-26, October 1996.

   [SPEKEIPR] Phoenix's IPR statement on SRP
          http://www.ietf.org/ietf/IPR/PHOENIX-SRP-RFC2945.txt

   [SRP]     Wu T., "The Secure Remote Password Protocol", ISOC NDSS
             Symposium, 1998.

   [SSH]       Ylonen, T., Kivinen, T., Rinne, T., Lehtinen, S.,
          "SSH Protocol Architecture", draft-ietf-secsh-connect-16.txt

   [STARTTLS] Hoffman, P., "SMTP Service Extension for Secure SMTP over TLS",
              RFC 2487, January 1998.

   [TLS]     Dierks, T., and Allen, C., "The TLS Protocol Version 1.0",
             RFC 2246, January 1999.


   [UPGRADE] Khare, R., Lawrence, S., "Upgrading to TLS Within HTTP/1.1",
             RFC 2817, May 2000.

   [XMPP]    Saint-Andre, P., "Extensible Messaging and Presence Protocol
	     (XMPP): Core", draft-ietf-xmpp-core-22.txt 
	     (awaiting RFC publication)

   [WILKES]  Wilkes, M.V., "Time-Sharing Computer Systems",
	     American Elsevier, New York, 1968.

   [WORM]    Spafford, E.H, "The Internet Worm Program: An Analysis",
	     Purdue Technical Report CSD-TR-823, 1988.
.fi
.eP
.fi
.eP
.LP
Security Considerations
.XS
Security Considerations
.XE
.sP
This document describes a number of security mechanisms.
.eP
.LP
Author's Address
.XS
Author's Address
.XE
.nf
Eric Rescorla <ekr@networkresonance.com>
Network Resonance, Inc.
2483 E. Bayshore Road
Palo Alto, CA 94303
Phone: (650)-812-7703

Internet Architecture Board <iab@iab.org>
IAB


Appendix A. IAB Members at the time of this writing

	Bernard Aboba
	Loa Andersson
	Brian Carpenter
	Leslie Daigle
	Patrik Fltstrm
	Bob Hinden
	Kurtis Lindqvist
	David Meyer
	Pekka Nikander
	Eric Rescorla
	Pete Resnick
	Jonathan Rosenberg
	Lixia Zhang 

.fi
.bp
.nf
Intellectual Property Statement

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Disclaimer of Validity

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Copyright Statement

   Copyright (C) The Internet Society (2006).  This document is subject
   to the rights, licenses and restrictions contained in BCP 78, and
   except as set forth therein, the authors retain all their rights.


Acknowledgment

   Funding for the RFC Editor function is currently provided by the
   Internet Society.
.fi






